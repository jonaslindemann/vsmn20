# Worksheet 3: Parametric Geometric Modeling and Visualization

## Introduction

In this worksheet, we will enhance the finite element application you developed in Worksheet 2 by implementing a **parametric geometric model**. This represents a significant advancement in your application's capabilities - instead of directly defining nodes and elements, you'll now describe your problem domain through geometric parameters (like width, height, etc.). This approach makes it much easier to modify the model and run studies with different geometries.

**Prerequisites:**

- Completed implementation of Worksheet 2 classes
- Basic understanding of Python object-oriented programming
- GMSH installation (included with CALFEM)

**Learning Objectives:**

After completing this worksheet, you will be able to:

1. Create parametric geometric models using CALFEM's geometry module
1. Generate finite element meshes automatically using GMSH
1. Visualize model geometry, meshes, and calculation results
1. Conduct parameter studies by varying geometric properties
1. Save and load models with geometric descriptions

## Setting Up Required Modules

In this worksheet, we need to import additional modules for geometry description, mesh generation, and visualization. Add the following imports to your module file:

```py hl_lines="8-10"
# -*- coding: utf-8 -*-

import json
import math
import sys

import calfem.core as cfc
import calfem.geometry as cfg  # For geometric modeling
import calfem.mesh as cfm      # For mesh generation
import calfem.vis_mpl as cfv   # For visualization
import calfem.utils as cfu     # Utility functions

import numpy as np
import tabulate as tb
```

!!! note

    The `calfem.vis_mpl` module provides visualization functions based on Matplotlib. This allows us to create visual representations of our model, mesh, and results.

## Parametric Geometric Modeling

In Worksheet 2, the `ModelParams` class defined our problem directly using nodes (coordinates) and elements (topology). Now, we need to modify this class to describe the geometry using parameters instead of explicit node/element definitions.

For example, instead of defining exact coordinates for a groundwater flow problem, we'll use parameters like:

* `w` - Width of the domain
* `h` - Height of the domain
* `d` - Depth of barrier
* `t` - Thickness of barrier

The element-level variables from Worksheet 2 (`coords`, `edof`, etc.) should be moved to the `ModelResult` class, as they will now be generated by the mesh generator.

Here's how the updated `ModelParams` class might look:

```python
class ModelParams:
    """Class defining parametric model properties"""
    def __init__(self):
        
        # Version tracking
        
        self.version = 1
        
        # Geometric parameters (example for groundwater problem)
        
        self.w = 100.0  # Width of domain
        self.h = 10.0   # Height of domain
        self.d = 5.0    # Depth of barrier
        self.t = 0.5    # Thickness of barrier
        
        # Material properties (example for groundwater problem)
        
        self.kx = 20.0  # Permeability in x-direction
        self.ky = 20.0  # Permeability in y-direction
        
        # Mesh control
        
        self.el_size_factor = 0.5  # Controls element size in mesh generation
        
        # Boundary conditions and loads will now reference markers 
        # instead of node numbers or degrees of freedom

        self.left_bc = 10
        self.right_bc = 20

        self.bcs = [
            [self.left_bc, 0.0],  # Left boundary condition (fixed value)
            [self.right_bc, 0.0]  # Right boundary condition (fixed value)
        ]

        self.loads = [
        ]
```

As a final step we need to add a `geometry()` method to the `ModelParams` class that creates and returns an instance of the geometry in the form of a `cfg.Geometry` instance. This will be later used to generate the mesh.

Here's an example implementation for a groundwater flow problem:

```python
class ModelParams:
    """Class defining parametric model properties"""
    def __init__(self):
        
        # ... (existing code)

    def geometry(self):
        """Create and return a geometry instance based on defined parameters"""
        
        # Create a geometry instance
        
        g = cfg.Geometry()
        
        # Use shorter variable names for readability
        
        w = self.w
        h = self.h
        t = self.t
        d = self.d
        
        # Define points for the geometry
        # Point indices start at 0
        
        g.point([0, 0])          # Point 0: Bottom left corner
        g.point([w, 0])          # Point 1: Bottom right corner
        g.point([w, h])          # Point 2: Top right corner
        g.point([0, h])          # Point 3: Top left corner
        
        # Add points for the barrier
        
        g.point([w/2-t/2, h])    # Point 4: Top left of barrier
        g.point([w/2+t/2, h])    # Point 5: Top right of barrier
        g.point([w/2-t/2, h-d])  # Point 6: Bottom left of barrier
        g.point([w/2+t/2, h-d])  # Point 7: Bottom right of barrier
        
        # Define splines (lines) connecting the points
        # Use markers for boundaries with conditions
        
        g.spline([0, 1])                         # Bottom boundary
        g.spline([1, 2])                         # Right boundary, marker for fixed value
        g.spline([2, 5], marker=self.right_bc)
        g.spline([5, 4])                         # Top of barrier
        g.spline([4, 3], marker=self.left_bc)    # Left boundary, marker for fixed value
        g.spline([3, 0])
        g.spline([4, 6])                         # Left side of barrier
        g.spline([5, 7])                         # Right side of barrier
        g.spline([6, 7])                         # Bottom of barrier
        
        # Define the surface (domain) using the spline indices
        # Surface is defined by a list of spline indices that form a closed loop
        
        g.surface([0, 1, 2, 3, 4, 5, 6, 7, 8])
        
        # Return the complete geometry
        return g
```

!!! important

    The geometry will vary depending on your chosen problem type. The above example is for a groundwater flow problem with a barrier. You'll need to adapt the point and spline definitions for your specific problem.

The key concept here is the use of **markers**. Markers are integer identifiers we assign to specific elements of the geometry (like lines or surfaces). Later, we'll use these markers to apply boundary conditions and loads to the correct parts of the model.

## Adding Mesh Generation to ModelSolver

GMSH is an open-source mesh generator that CALFEM interfaces with through the `calfem.mesh` module. It can create a finite element mesh from our geometric model.

The `ModelSolver` class needs to generate a mesh based on the geometry before performing the finite element calculation. To acomplish this we modify the `execute()` method to do this:

```python
class ModelSolver:
    """Class for solving the finite element model"""
    def __init__(self, model_params, model_result):
        self.model_params = model_params
        self.model_result = model_result
    
    def execute(self):
        """Perform mesh generation and finite element computation"""
        
        # Create shorter references to input variables

        ep = self.model_params.ep
        kx = self.model_params.kx
        ky = self.model_params.ky
        
        # Get geometry from model_params

        geometry = self.model_params.geometry()
        
        # Store geometry in results for visualization
        
        self.model_result.geometry = geometry
        
        # Set up mesh generation
        
        el_type = 3        # 3 = 4-node quadrilateral element
        dofs_per_node = 1  # 1 for scalar problem (flow, heat), 2 for vector (stress)
        
        # Create mesh generator
        
        mesh = cfm.GmshMeshGenerator(geometry)
        
        # Configure mesh generator
        
        mesh.el_type = el_type
        mesh.dofs_per_node = dofs_per_node
        mesh.el_size_factor = self.model_params.el_size_factor
        mesh.return_boundary_elements = True
        
        # Generate mesh
        
        coords, edof, dofs, bdofs, element_markers, boundary_elements = mesh.create()
        
        # Store mesh data in results
        
        self.model_result.coords = coords
        self.model_result.edof = edof
        self.model_result.dofs = dofs
        self.model_result.bdofs = bdofs
        self.model_result.element_markers = element_markers
        self.model_result.boundary_elements = boundary_elements
        self.model_result.el_type = el_type
        self.model_result.dofs_per_node = dofs_per_node
        
        # TODO: 
        # 
        # Now continue with FE calculation similar to Worksheet 2
        # but using the generated mesh data
        
        # Extract node and element data from mesh for element calculations
        # ...
```

!!! note

    The code above needs to be modified for the problem type selected. The code above shows the ground water problem. For the heat transfer and plane stress problems, the element type and degrees of freedom per node will be different.

## Handling Boundary Conditions and Loads

In Worksheet 2, we directly specified loads and boundary conditions using node/degree of freedom indices. Now, we need to use markers to apply them. CALFEM provides utility functions for this:

```python
class ModelSolver:

    # ... (existing code)

    def execute(self):

        # Initialize the global stiffness matrix and load vector

        n_dofs = np.max(dofs)
        K = np.zeros((n_dofs, n_dofs))
        f = np.zeros((n_dofs, 1))

        bcs = self.model_params.bcs
        loads = self.model_params.loads

        # TODO:
        #
        # Assemble element contributions to global stiffness matrix
        # ... (similar to Worksheet 2)

        # Apply boundary conditions based on markers

        bc_prescr = np.array([], int)
        bc_val = np.array([], float)

        # For each boundary condition marker in model_params

        for bc in bcs:
            bc_prescr, bc_val = cfu.applybc(
                bdofs, bc_prescr, bc_val, bc[0], bc[1]
            )

        for load in loads:
            cfu.apply_force_total(bdofs, f, load[0], load[1])

        # Solve equation system

        a, r = cfc.solveq(K, f, bc_prescr, bc_values)

        # Store displacement and reaction forces

        self.model_result.a = a
        self.model_result.r = r

        # TODO:
        #
        # Calculate element displacements, stresses/flows, etc.
        # ... (similar to Worksheet 2)

        # Calculate maximum flow/stress for parameter studies

        element_values = np.sqrt(np.sum(self.model_result.es**2, axis=1))
        self.model_result.max_value = np.max(element_values)
```

## Results Visualization

To help understand the results, we'll create a new class called `ModelVisualization` that handles visualization of different aspects of the model. This class takes a ModelParams and ModelResult instance as input and provides methods to display the geometry, mesh, nodal values, element values, and deformed mesh (for stress problems).


```python
class ModelVisualization:
    """Class for visualizing model geometry, mesh, and results"""
    
    def __init__(self, model_params, model_result):
        """Constructor"""
        self.model_params = model_params
        self.model_result = model_result
        
        # Store references to visualization windows

        self.geom_fig = None
        self.mesh_fig = None
        self.nodal_val_fig = None
        self.element_val_fig = None
        self.deformed_fig = None
    
    def show_geometry(self):
        """Display model geometry"""

        # Get the geometry from results

        geometry = self.model_result.geometry

        # Create a new figure
        
        cfv.figure()
        cfv.clf()
        
        # Draw geometry

        cfv.draw_geometry(geometry, draw_points=True, label_points=True, 
                         draw_line_numbers=True, title="Model Geometry")
    
    def show_mesh(self):
        """Display finite element mesh"""

        # Create a new figure

        cfv.figure()
        cfv.clf()
        
        # Draw mesh

        cfv.draw_mesh(
            coords=self.model_result.coords,
            edof=self.model_result.edof,
            dofs_per_node=self.model_result.dofs_per_node,
            el_type=self.model_result.el_type,
            filled=True,
            title="Finite Element Mesh"
        )
    
    def show_nodal_values(self):
        """Display nodal values (e.g., temperature, pressure)"""

        # TODO:
        #   
        # Implement this method to display nodal values


    
    def show_element_values(self):
        """Display element values (e.g., flows, stresses)"""

        # TODO:
        #   
        # Implement this method to display element values

    
    def show_deformed_mesh(self, scale_factor=1.0):
        """Display deformed mesh (for stress problems)"""

        # TODO:
        #   
        # Implement this method to display deformed mesh
    
    def wait(self):
        """Wait for user to close all visualization windows"""
        cfv.show_and_wait()
```

## Conducting Parameter Studies

One of the key advantages of parametric modeling is the ability to easily perform parameter studies. Here's an example of how to implement a parameter study:

```python
# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import flowmodel as fm

def run_parameter_study():
    """Run a parameter study by varying the barrier depth"""
    
    # Parameters to vary

    d_values = np.linspace(3.0, 7.0, 10)
    max_flow_values = []
    
    # Run simulation for each value

    for d in d_values:
        print(f"Simulating with barrier depth d = {d:.2f}...")
        
        # Create model with current parameter

        model_params = fm.ModelParams()
        model_params.d = d  # Set current barrier depth
        
        # Other parameters remain constant

        model_params.w = 100.0
        model_params.h = 10.0
        model_params.t = 0.5
        model_params.kx = 20.0
        model_params.ky = 20.0
        
        # Create result storage and solver

        model_result = fm.ModelResult()
        solver = fm.ModelSolver(model_params, model_result)
        
        # Run the simulation

        solver.execute()
        
        # Store the maximum flow for this configuration

        max_flow_values.append(model_result.max_value)
        print(f"Maximum flow value: {model_result.max_value:.4f}")
    
    # Plot the results

    plt.figure(figsize=(10, 6))
    plt.plot(d_values, max_flow_values, 'o-', linewidth=2)
    plt.grid(True)
    plt.xlabel('Barrier Depth (d)')
    plt.ylabel('Maximum Flow')
    plt.title('Parameter Study: Effect of Barrier Depth on Maximum Flow')
    plt.savefig('parameter_study.png')
    plt.show()
    
    # Return results for further analysis if needed

    return d_values, max_flow_values

if __name__ == "__main__":
    run_parameter_study()
```

This script creates a series of models with varying barrier depths, solves each one, and plots the maximum flow values against the barrier depth.

## Example Problems

Below are the specifications for the three problem types you can choose from. Remember to select just one problem type to implement.

### Groundwater Flow Problem

![Groundwater Flow Problem](images/gw.svg)

**Geometric parameters:**

- h = 10.0 (height of domain)
- w = 100.0 (width of domain)
- d = 5.0 (depth of barrier)
- t = 0.5 (thickness of barrier)

**Material properties:**

- k_x = k_y = 20 m/day (permeability in x and y directions)

**Boundary conditions:**

- Fixed pressure head (phi) of 10.0 m on left and 0.0 m on the right boundary.

### Heat Transfer Problem

![Heat Transfer Problem](images/temp.svg)

**Geometric parameters:**

- h = 0.1 (height of domain)
- w = 0.1 (width of domain)
- a = 0.01 (width of left heat source)
- b = 0.01 (width of right heat source)
- x = 0.01 (distance from left boundary to left heat source)
- y = 0.01 (distance from right boundary to right heat source)

**Material properties:**

- lambda_x = lambda_y = 1.7 W/mC (thermal conductivity in x and y directions)

**Boundary conditions:**

- Fixed temperature 20.0 on the surrounding boundaries and 120 degrees in the opening.

### Plane Stress Problem

![Plane Stress Problem](images/stress.svg)

**Geometric parameters:**

- h = 0.1 (height of domain)
- w = 0.3 (width of domain)
- a = 0.05 (width of left cutout)
- b = 0.025 (height of cutout)

**Material properties:**

- E = 2.08e11 Pa (Young's modulus)
- ν = 0.3 (Poisson's ratio)
- t = 0.010 m (thickness)

**Boundary conditions:**

- Fixed displacement on left edge
- Distributed load q = 100 kN/m on right edge

## Submission Requirements

Your submission should include:

1. **Python Files:**
    - Updated `ModelParams` class with parametric description and `geometry()` method
    - Updated `ModelSolver` class with mesh generation
    - New `ModelVisualization` class with visualization methods
    - Main program for standard execution
    - Parameter study program
2. **Example Files:**
    - A JSON file with saved model parameters
    - Screenshots of visualizations (geometry, mesh, results)
    - Plot of parameter study results
3. **Documentation:**
    - Brief explanation of your geometric model
    - Analysis of parameter study results
    - Any challenges encountered and how you solved them

Package all files in a ZIP archive for submission.

## Troubleshooting Guide

1. **GMSH Not Found Error:**
    - Ensure GMSH is properly installed with CALFEM
    - Try reinstalling CALFEM with `pip install calfem-python`
2. **Mesh Generation Errors:**
    - Check that your geometry is properly defined with no gaps in the boundary
    - Ensure all points are correctly connected by splines
    - Try increasing the `el_size_factor` for simpler meshes
3. **Visualization Not Showing:**
    - Make sure you're calling `wait()` after showing visualizations
    - Check that Matplotlib is properly installed
    - Try running with a different backend: `import matplotlib; matplotlib.use('TkAgg')`
4. **Parameter Study Issues:** 
    - Start with a small number of parameter values for testing
    - Add print statements to track progress and debug issues
    - Check that results are being properly stored in the result object

## Further Reading

- [CALFEM for Python Documentation](https://calfem-for-python.readthedocs.io/)
- [GMSH Documentation](https://gmsh.info/doc/texinfo/gmsh.html)

## Example results

=== "Groundwater Flow Problem (triangular mesh)"

    ```
    {!flowmodel_v3_el2.txt!}
    ```
=== "Groundwater Flow Problem (quad mesh)"

    ```
    {!flowmodel_v3_el3.txt!}
    ```

=== "Heat Transfer Problem (triangular mesh)"

    ```
    {!heatmodel_v3_el2.txt!}
    ```
=== "Heat Transfer Problem (quad mesh)"

    ```
    {!heatmodel_v3_el3.txt!}
    ```

=== "Plane Stress Problem (triangular mesh)"

    ```
    {!stressmodel_v3_el2.txt!}
    ```
=== "Plane Stress Problem (quad mesh)"

    ```
    {!stressmodel_v3_el3.txt!}
    ```

